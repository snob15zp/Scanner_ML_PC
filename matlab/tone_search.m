function [ Signal, FftS, Am, a, f, p ] = tone_search( Tm, Fd, mz, FftL, T, Signal, a, f, p ) % функция поиска и удаления тонов
    Signal=Signal-a*sind((f*360).*T+p); % вычисляем разностный сигнал
         %% Спектральное представление входного сигнала
    FftS=abs(fft(Signal,FftL));     % амплитуды преобразования Фурье сигнала
    FftS=2*FftS./FftL;              % нормировка спектра по амплитуде
    %FftS(1)=FftS(1)/2;              % нормировка постоянной составляющей в спектре
        %% Поиск частоты тона и вычисление
    [Am,im]=max(FftS); % максимум в спектре , где Am - амплитуда спички , im - индекс в массиве FftS начиная с 1 а не с 0
    f=(im-1)*Fd/FftL;  % вычисление частоты тона , im-1 потому что i начинается с 1 а не с 0
        %% Аппроксимация частоты вычета по максимуму вектора
    hf=0.01;ff=0; % шаг и точность оптимизированы на быстродействие , отклонение ff сбросить
    while abs(hf)>1E-6              % если шаг не дошол до оптимальной точности , то
	    f=f+hf;                     % частоту инкрементируем на шаг 
        sc=0;ss=0;                  % начальные присвоения суммам
        for i=0:Tm*Fd               % количество индексов массива времени Tm*Fd+1
            sc=sc+Signal(i+1)*cosd(f*360*i/Fd); % первая сумма вектора
            ss=ss+Signal(i+1)*sind(f*360*i/Fd); % вторая сумма вектора
        end
        s=sc^2+ss^2;                % функция отклонения - сумма квадратов сумм вектора
        if s<ff                     % если проскочили максимальное значение , то
            hf=-hf/2;               % деление на 2 и разворот шага в обратную сторону
        end
        ff=s;                       % прошлая сумма равна текущей
    end                             % конец аппроксимации по частоте
        %% Расчёт амплитуды и фазы по векторному методу , при условии известной частоты
    cs=0;cc=0;ss=0;yc=0;ys=0;       % начальные присвоения суммам
    for i=0:Fd*Tm                   % количество индексов массива времени
        cs=cs+sind(f*720*i/Fd)/2;   % упрощение cos(x)*sin(x)=sin(2*x)/2
        cc=cc+cosd(f*360*i/Fd)^2;   % время начинается с нуля ,
        ss=ss+sind(f*360*i/Fd)^2;   % а индекс начинается с единицы
        yc=yc+Signal(i+1)*cosd(f*360*i/Fd); % поэтому в синусах и косинусах стоит i
        ys=ys+Signal(i+1)*sind(f*360*i/Fd); % а в сигнале стоит индекс i+1
    end                             % конец накопления сумм для матрицы
    A=[cc cs                        % решение системы линейных уравнений (СЛУ)
       cs ss];                      % присвоение сумм матрице А
    B=[yc; ys;];                    % присвоение сумм матрице В
    X=A\B;                          % вектор решения СЛУ
    an=0;%(mean(FftS(1:299990*mz))+mean(FftS(300050*mz:Fd*mz/2)))/2; % средняя амплитуда шума
    a=sqrt(X(1)^2+X(2)^2)-an;       % амплитуда сигнала вычета
    p=180+sign(X(1))*(acosd(sign(X(2))/sqrt(1+(X(1)/X(2))^2))-180); % фаза сигнала вычета 0...360
end

